macro(string_join var delimiter str_list)
    set(_ret "")
    foreach(_str ${str_list})
        if(_ret STREQUAL "")
            set(_ret "${_str}")
        else(_ret STREQUAL "")
            set(_ret "${_ret}${delimiter}${_str}")
        endif(_ret STREQUAL "")
    endforeach(_str ${str_list})
    foreach(_str ${ARGN})
        if(_ret STREQUAL "")
            set(_ret "${_str}")
        else(_ret STREQUAL "")
            set(_ret "${_ret}${delimiter}${_str}")
        endif(_ret STREQUAL "")
    endforeach(_str ${ARGN})
    set(${var} "${_ret}")
endmacro(string_join var delimiter str_list)

macro(set_test_build_depends test_name)
    add_custom_target(${test_name}_dependencies)
    add_dependencies(${test_name}_dependencies ${ARGN})
    add_test("builddep_${test_name}" "${CMAKE_COMMAND}" --build
        ${CMAKE_BINARY_DIR} --target ${test_name}_dependencies)
    set("${test_name}_has_build_depends" 1)
    # message(STATUS "Creating dependencies for ${test_name} -- ${ARGN}")
    set_tests_properties (${test_name} PROPERTIES DEPENDS "builddep_${test_name}")
endmacro(set_test_build_depends test_name ${ARGN})

macro(update_test_build_depends test_name)
    set_target_properties(${test_name}_dependencies PROPERTIES DEPENDS ${ARGN})
endmacro(update_test_build_depends test_name)

macro(set_test_dependencies test_name)
    set(deps ${ARGN})
    if("${test_name}_has_build_depends")
        list(APPEND deps "builddep_${test_name}")
    endif("${test_name}_has_build_depends")
    # cmake has very quirky syntax...
    string_join(alldeps ";" ${deps})
    # message(STATUS "Updating dependencies for ${test_name} -- ${alldeps}")
    set_tests_properties (${test_name} PROPERTIES DEPENDS "${alldeps}")
endmacro(set_test_dependencies test_name ${ARGN})
macro(build_test DSTFILE SRCFILE LIBRARIES)
    # Add a build target for the test binary
    add_executable("${DSTFILE}" "${SRCFILE}")
    target_link_libraries("${DSTFILE}" ${LIBRARIES})
endmacro(build_test)

macro(run_test NAME DSTFILE)
    # This add_test() call causes the ctest program to be called on the
    # current source and binary directories. The ctest program then builds
    # the DSTFILE binary by calling cmake (which we suppress here) and make,
    # and then runs DSTFILE
    set(binary ${DSTFILE})
    if (${DSTFILE} MATCHES ".sh$")
        set(binary env bash ${DSTFILE})
    endif (${DSTFILE} MATCHES ".sh$")
    add_test ("${NAME}" "${CMAKE_CTEST_COMMAND}"
              # Specify the source and build directories for the Cmake/make
              # steps that gets executed by CTest (except we suppress the
              # CMake step in this CTest run, but we still have to specify the
              # directories)
              --build-and-test "${CMAKE_CURRENT_SOURCE_DIR}"
                               "${CMAKE_CURRENT_BINARY_DIR}"

              # If CTest were to run Cmake, it should use same CMake generator
              # as we use in the parent Cmake. We suppress the CMake call, but
              # the "--build-generator" parameter is mandatory so we have to
              # specify it anyway. Without it, we get this error:
              # "--build-and-test requires that both the generator and 
              #  makeprogram be provided using the --build-generator and 
              #  --build-makeprogram command line options."
              --build-generator "${CMAKE_GENERATOR}"

              # Use same make program as the parent CMake.
              --build-makeprogram "${CMAKE_MAKE_PROGRAM}"

              # Do NOT run CMake. The CMakeCache.txt file generated by having
              # add_subdirectory() in the parent directories is fine, and
              # if we were to let CTest re-run CMake, we'd have to figure out
              # directory locations all over again - this way, we inherit
              # everything from the CMakeCache.txt generated by the parent
              # CMake.
              --build-nocmake

              # Normally, CTest runs "make clean" before building any target,
              # so that only the most recently built target would remain in
              # the build directory. I assume we don't want that, but want to
              # be able to run them manually as well. Do tell CTest not to do
              # "make clean."
              --build-noclean

              # When we build and run this test, build only the binary
              # required for this test
              --build-target "${DSTFILE}"

              # If any test fails, print its output to stdout.
              # ... except that does not actually work. When running the
              # test suite with
              # /usr/bin/ctest --force-new-ctest-process -V
              # then the debugging output shows --output-on-failure being
              # passed to the spawned ctest processes, but without -V, they
              # still don't print anything in case of failure. Maybe a bug.
              # To get output, we have to pass it via ARGS to "make test".
              --output-on-failure

              # And finally the binary that should be run as the actual test
              --test-command ${binary} ${ARGN})
endmacro(run_test NAME DSTFILE)

# The SRCFILE parameter to this macro is the file name of the source file to
# build. The LIBRARIES parameter is any libraries that should be linked in.
# Any additional parameters are added to the command line of the test
# executable that gets run.
macro(build_and_run_test SRCFILE LIBRARIES)
    # The name of the binary executable is equal to the name of the source
    # file, minus the extension
    get_filename_component (DSTFILE "${SRCFILE}" NAME_WE)

    build_test ("${DSTFILE}" "${SRCFILE}" "${LIBRARIES}")
    # The name of the test here is the same as the name of the test
    # executable file
    run_test ("${DSTFILE}" "${DSTFILE}" ${ARGN})
    set_test_build_depends(${DSTFILE} ${DSTFILE})
endmacro(build_and_run_test)


if(DEFINED ENV{CHECKS_EXPENSIVE})
    run_test(full_c59 ${CADO_NFS_SOURCE_DIR}/factor.sh 90377629292003121684002147101760858109247336549001090677693 -t 2)
    set_test_build_depends(full_c59 polyselect2l polyselect_ropt freerel makefb las dup1 dup2 purge merge merge-dl replay replay-dl sm reconstructlog-dl characters bwc_full plingen_pz sqrt)
    find_program(MAGMA magma)
    if (MAGMA)
        set_test_build_depends(full_p59 full_c59_test_dependencies debug_renumber)
        run_test(full_p59 ${CMAKE_CURRENT_SOURCE_DIR}/test_full_p59.sh ${CADO_NFS_SOURCE_DIR})
        set_test_build_depends(full_gfp3 full_c59_test_dependencies debug_renumber)
        run_test(test_gfp3 ${CMAKE_CURRENT_SOURCE_DIR}/test_gfp3.sh ${CADO_NFS_SOURCE_DIR} ${CADO_NFS_BINARY_DIR})
    endif(MAGMA)
endif(DEFINED ENV{CHECKS_EXPENSIVE})

include_directories("${CMAKE_CURRENT_SOURCE_DIR}")
add_library (tests STATIC test_iter.c tests_common.c)
target_link_libraries (tests ${gmp_libname})

build_test(test_tests_common test_tests_common.c tests)
run_test(tests_common_1 test_tests_common)
run_test(tests_common_2 test_tests_common -seed)
run_test(tests_common_3 test_tests_common -seed 1)
set_tests_properties(tests_common_3 PROPERTIES PASS_REGULAR_EXPRESSION "Using random seed=1")
run_test(tests_common_4 test_tests_common -seed a)
run_test(tests_common_5 test_tests_common -seed "")
set_tests_properties(tests_common_2 tests_common_4 tests_common_5 PROPERTIES WILL_FAIL 1)
run_test(tests_common_6 test_tests_common -iter 10)
set_tests_properties(tests_common_6 PROPERTIES PASS_REGULAR_EXPRESSION "Using 10 iterations")

build_and_run_test(test_iceildiv.c "")

add_subdirectory (utils)
add_subdirectory (sieve)
add_subdirectory (polyselect)
add_subdirectory (filter)
add_subdirectory (linalg)
add_subdirectory (gf2x)
